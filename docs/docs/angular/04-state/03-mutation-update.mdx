---
title: 'mutationUpdate'
---

import Link from '@docusaurus/Link'

## Overview
`mutationUpdate` is analogous to <Link to="https://www.apollographql.com/docs/react/data/mutations/#the-update-function">`update`</Link> option passed to [`mutate`](../../fetching/mutations/mutate) method in `Apollo`.  
It is used to update the cache following the execution of a mutation.

## Usage
As stated previously in the [`mutations guide`](../../fetching/mutations/mutate/#cache-normalisation), unlike `UPDATE_BOOK_MUTATION`, updating the cache after executing `ADD_BOOK_MUTATION` requires manual intervention.

Let's build on the same example used in [fetching guide](../../fetching/queries/) to demonstrate how `mutationUpdate` can be used to update the cache after executing `ADD_BOOK_MUTATION`.  

In this example, we have a library management app. A book is present in two lists stored in the cache, one for all books in the library and one for books written by an author.

First we add the mutation to `book.graphql`
```graphql title="library/gql/book.graphql"
mutation AddBook($book: AddBookInput!) {
  addBook(book: $book) {
    ...BookFragment
  }
}
```

Then, we define two state slices, one for managing `book` state and one for `author` state and add them to **Apollo Orbit** module as [demonstrated previously](../state-slice/#adding-state).

### `bookState`
```typescript title="library/states/book.state.ts"
import { state } from '@apollo-orbit/angular/state';
import { ADD_BOOK_MUTATION, BOOKS_QUERY } from '../../graphql/types';

export const bookState = state(descriptor => descriptor
  .mutationUpdate(ADD_BOOK_MUTATION, (cache, info) => {
    const addBook = info.data?.addBook;
    if (!addBook) return;

    cache.updateQuery({ query: BOOKS_QUERY }, data => data ? { books: [...data.books, addBook] } : data);
  })
);
```

### `authorState`
```typescript title="library/states/author.state.ts"
import { identifyFragment } from '@apollo-orbit/angular';
import { state } from '@apollo-orbit/angular/state';
import { ADD_BOOK_MUTATION, AuthorFragmentDoc } from '../../graphql/types';

export const authorState = state(descriptor => descriptor
  .mutationUpdate(ADD_BOOK_MUTATION, (cache, info) => {
    const addBook = info.data?.addBook;
    if (!addBook) return;
    
    const authorId = info.variables?.book.authorId as string;
    cache.updateFragment(
      identifyFragment(AuthorFragmentDoc, authorId),
      author => author ? ({ ...author, books: [...author.books, addBook] }) : author
    );
  })
);
```

`info` argument is of type `MutationInfo<AddBookMutationData, AddBookMutationVariables>` and all logic in `mutationUpdate` handler is type-safe.

`identifyFragment` is a helper function provided by **Apollo Orbit** for returning a fragment object that uniquely identifies a fragment in the cache.

### Execute mutation
```typescript title="library/books.component.ts"
export class BooksComponent {
  private readonly apollo = inject(Apollo);
  
  protected addBook(book: AddBookInput): void {
    // code-add-line
    this.apollo.mutate({ mutation: ADD_BOOK_MUTATION, variables: { book } }).subscribe();
    // code-remove-start
    this.apollo.mutate({
      mutation: ADD_BOOK_MUTATION,
      variables: { book },
      update(cache, result) {
        const addBook = result.data?.addBook;
        if (!addBook) return;

        // Update full list of books
        cache.updateQuery({ query: BOOKS_QUERY }, data => data ? { books: [...data.books, addBook] } : data);

        // Update author's list of books
        cache.updateFragment(
          identifyFragment(AuthorFragmentDoc, book.authorId),
          author => author ? ({ ...author, books: [...author.books, addBook] }) : author
        );
      }
    }).subscribe();
    // code-remove-end
  }
}
```

Now, when a component calls `this.apollo.mutate({ mutation: ADD_BOOK_MUTATION, variables: { book } }).subscribe()` the above mutation update functions are automatically executed and the UI displaying books and author books is updated.

The example above demonstrates how the same mutation can be handled independently by different states, achieving separation of concerns (SoC) and complete decoupling between component and state logic.

:::note
`mutationUpdate` also accepts the name of the mutation as a `string` argument. This can be used in projects that do not have codegen setup.  
So the above code can be updated to `.mutationUpdate('AddBook', (cache, info) =>` and the rest of the code remains the same, except it won't be type-safe.
:::

### Passing additional context
If you need to pass additional context outside of the mutation variables, then you can use the `context` option of the `mutate` method.

```typescript
this.apollo.mutate({
  mutation: ADD_BOOK_MUTATION,
  variables: { book },
  // code-add-line
  context: { additionalData: 'some data' }
}).subscribe();
```

This context can then be accessed in the `mutationUpdate` handler via `info.context`.

```typescript title="library/states/book.state.ts"
import { state } from '@apollo-orbit/angular/state';
import { ADD_BOOK_MUTATION } from '../../graphql/types';

export const bookState = state(descriptor => descriptor
  .mutationUpdate(ADD_BOOK_MUTATION, (cache, info) => {
    const addBook = info.data?.addBook;
    // code-add-line
    const { additionalData } = info.context;
    ...
  })
);
```
